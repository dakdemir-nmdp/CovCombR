---
title: "Combining Incomplete Covariance Matrices: Iris Example"
author: "CovCombR Package"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: true
    toc_depth: 2
  html_document:
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{Combining Incomplete Covariance Matrices: Iris Example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  fig.width = 6,
  fig.height = 4,
  warning = FALSE,
  message = FALSE
)
```

## Introduction

This vignette demonstrates how to use the `CovCombR` package to combine incomplete covariance matrices. We'll use the classic iris dataset to illustrate a scenario where different variables are observed in different samples, similar to the example from the `CovCombR` package.

### The Problem

Suppose you have multiple studies that each measure different subsets of variables. For example:
- Study 1 measures variables 1 and 2
- Study 2 measures variables 1 and 3
- Study 3 measures variables 2 and 4

How can you estimate the complete covariance matrix for all 4 variables?

The `CovCombR` package solves this problem using an EM algorithm that properly accounts for:
- Different sample sizes (degrees of freedom)
- Different missing data patterns
- Uncertainty quantification via bootstrap or plugin standard errors

## Example with Iris Data

We'll use the virginica species from the iris dataset to create a realistic example.

### Load the Package and Data

```{r load}
library(CovCombR)
data(iris)

# Rename columns for clarity
colnames(iris) <- c("S.L", "S.W", "P.L", "P.W", "Species")

# Focus on virginica species
iris_virginica <- iris[iris$Species == "virginica", ]
cat("Sample size:", nrow(iris_virginica), "\n")
```

### Creating Incomplete Covariance Matrices

We'll simulate a scenario where different studies measure different subsets of the 4 morphological variables. Setting a seed for reproducibility:

```{r create_covlist}
set.seed(1234)

# Create 3 partial covariance matrices with different sample sizes
CovList <- vector(mode = "list", length = 3)

# Study 1: Sepal measurements (variables 1 and 2), n=20
CovList[[1]] <- cov(iris_virginica[sample(1:50, 20), c(1, 2)])

# Study 2: Sepal length and Petal length (variables 1 and 3), n=25
CovList[[2]] <- cov(iris_virginica[sample(1:50, 25), c(1, 3)])

# Study 3: Sepal width and Petal width (variables 2 and 4), n=30
CovList[[3]] <- cov(iris_virginica[sample(1:50, 30), c(2, 4)])

# Name the samples
names(CovList) <- c("Study1", "Study2", "Study3")

# Display the incomplete covariance matrices
cat("\nStudy 1 (Sepal.Length x Sepal.Width):\n")
print(CovList[[1]])

cat("\nStudy 2 (Sepal.Length x Petal.Length):\n")
print(CovList[[2]])

cat("\nStudy 3 (Sepal.Width x Petal.Width):\n")
print(CovList[[3]])
```

### Note the Missing Information

Each study provides covariances for only 2 of the 4 variables:
- **Missing**: Covariance between (Sepal.Width, Petal.Length)
- **Missing**: Covariance between (Petal.Length, Petal.Width)
- **Missing**: Covariance between (Sepal.Length, Petal.Width)

The `CovCombR` algorithm will estimate these missing covariances by combining information across studies.

### Fit the Wishart EM Model

```{r fit_model}
# Degrees of freedom for each study (sample sizes - 1)
nu <- c(Study1 = 20 - 1, Study2 = 25 - 1, Study3 = 30 - 1)

# Fit the model
fit <- fit_covcomb(CovList, nu = nu, se_method = "plugin")

# Display results
print(fit)
```

### Extract the Combined Covariance Matrix

```{r extract_result}
# Get the combined covariance estimate
Sigma_combined <- fit$Sigma_hat

cat("\nCombined Covariance Matrix:\n")
print(round(Sigma_combined, 4))
```

### Compare with Full Data

If we had access to all 50 observations with all 4 variables measured, what would we get?

```{r compare_full}
# True covariance from complete data
Sigma_full <- cov(iris_virginica[, 1:4])

cat("\nFull Data Covariance Matrix:\n")
print(round(Sigma_full, 4))

cat("\nDifference (Combined - Full):\n")
print(round(Sigma_combined - Sigma_full, 4))
```

The combined estimate successfully recovers the covariances that were never jointly observed in any single study!

### Standard Errors

The plugin standard errors show the uncertainty in our estimates:

```{r standard_errors}
cat("\nStandard Errors:\n")
print(round(fit$Sigma_se, 4))

# Which entries have higher uncertainty?
cat("\nRelative standard errors (SE / |estimate|):\n")
rel_se <- fit$Sigma_se / abs(Sigma_combined)
print(round(rel_se, 3))
```

Entries that were never jointly observed in any study have `NA` standard errors (infinite uncertainty from the plugin formula). For accurate inference on these entries, use bootstrap standard errors instead.

### Visualizing the Results

```{r visualize, fig.width=8, fig.height=4, fig.alt="Side-by-side heatmaps comparing the CovCombR combined covariance with the full-data covariance for the iris example."}
par(mfrow = c(1, 2))

# Combined estimate
# Plot using a grid where position (i,j) shows matrix element [i,j]
image(1:4, 1:4, Sigma_combined,
  xlab = "", ylab = "", main = "Combined Estimate",
  xaxt = "n", yaxt = "n", col = hcl.colors(20, "Blue-Red 3")
)
axis(1, at = 1:4, labels = colnames(Sigma_combined), las = 2, cex.axis = 0.8)
axis(2, at = 1:4, labels = rownames(Sigma_combined), las = 1, cex.axis = 0.8)
for (i in 1:4) {
  for (j in 1:4) {
    text(j, i, sprintf("%.2f", Sigma_combined[i, j]), cex = 0.8)
  }
}

# Full data covariance
# Plot using a grid where position (i,j) shows matrix element [i,j]
image(1:4, 1:4, Sigma_full,
  xlab = "", ylab = "", main = "Full Data",
  xaxt = "n", yaxt = "n", col = hcl.colors(20, "Blue-Red 3")
)
axis(1, at = 1:4, labels = colnames(Sigma_full), las = 2, cex.axis = 0.8)
axis(2, at = 1:4, labels = rownames(Sigma_full), las = 1, cex.axis = 0.8)
for (i in 1:4) {
  for (j in 1:4) {
    text(j, i, sprintf("%.2f", Sigma_full[i, j]), cex = 0.8)
  }
}
```

### More Realistic Scenario: Different Sample Sizes

Let's demonstrate with very different sample sizes across studies:

```{r different_sizes}
set.seed(2025)

# Study 1: Small sample (n=10)
CovList2 <- list(
  Small = cov(iris_virginica[sample(1:50, 10), c(1, 2)]),
  Medium = cov(iris_virginica[sample(1:50, 25), c(2, 3)]),
  Large = cov(iris_virginica[sample(1:50, 45), c(3, 4)])
)

nu2 <- c(Small = 9, Medium = 24, Large = 44)

fit2 <- fit_covcomb(CovList2, nu = nu2, se_method = "plugin")
print(fit2)

cat("\nCombined estimate:\n")
print(round(fit2$Sigma_hat, 4))
```

The algorithm automatically weights studies appropriately based on their sample sizes.

## Bootstrap Standard Errors (Optional)

For more accurate standard errors, especially for entries that were never jointly observed, use bootstrap:

```{r bootstrap, eval=TRUE}
# Bootstrap takes longer but provides better uncertainty estimates
# Note: This example uses fewer variables with overlap for better convergence
CovList_boot <- list(
  Study1 = cov(iris_virginica[sample(1:50, 25), c(1, 2, 3)]),
  Study2 = cov(iris_virginica[sample(1:50, 30), c(2, 3, 4)]),
  Study3 = cov(iris_virginica[sample(1:50, 20), c(1, 3, 4)])
)
nu_boot <- c(Study1 = 24, Study2 = 29, Study3 = 19)

set.seed(1234)
fit_boot <- fit_covcomb(
  CovList_boot, nu = nu_boot,
  se_method = "bootstrap",
  control = list(bootstrap = list(B = 100, seed = 1234, progress = FALSE, verbose = FALSE))
)

cat("\nBootstrap Standard Errors (Sigma_se):\n")
print(round(fit_boot$Sigma_se, 4))

cat("\nBootstrap metadata:\n")
cat("  Total replicates:", fit_boot$bootstrap$B, "\n")
cat("  Successful:", fit_boot$bootstrap$successes, "\n")
cat("  Failed:", fit_boot$bootstrap$failures, "\n")
```

Bootstrap standard errors account for both sampling variance and EM imputation uncertainty, providing valid inference even for entries never jointly observed.

## Summary

The `CovCombR` package provides a principled way to combine incomplete covariance matrices:

1. **Input**: Sample covariance matrices from different studies (like from `cov(X)`)
2. **Specify**: Degrees of freedom (sample sizes) for each study
3. **Output**: Combined covariance estimate at the same scale as inputs
4. **Inference**: Plugin or bootstrap standard errors for uncertainty quantification

Key advantages:
- Handles arbitrary missing data patterns
- Accounts for different sample sizes
- Provides valid statistical inference
- Compatible with existing workflows (`cov()` output)

## References

- Anderson, T.W. (2003). *An Introduction to Multivariate Statistical Analysis* (3rd ed.). Wiley.
- McLachlan, G.J., & Krishnan, T. (2008). *The EM Algorithm and Extensions* (2nd ed.). Wiley.

## Session Information

```{r session}
sessionInfo()
```
